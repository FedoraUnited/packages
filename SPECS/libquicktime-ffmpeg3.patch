---
 plugins/ffmpeg/audio.c      |   14 ++--
 plugins/ffmpeg/lqt_ffmpeg.c |   92 +++++++++++++-------------
 plugins/ffmpeg/video.c      |  154 ++++++++++++++++++++++----------------------
 3 files changed, 130 insertions(+), 130 deletions(-)

Index: libquicktime/plugins/ffmpeg/audio.c
===================================================================
--- libquicktime.orig/plugins/ffmpeg/audio.c
+++ libquicktime/plugins/ffmpeg/audio.c
@@ -211,10 +211,10 @@ static void init_compression_info(quickt
   quicktime_audio_map_t *track_map = &file->atracks[track];
   quicktime_ffmpeg_audio_codec_t *codec = track_map->codec->priv;
 
-  if((codec->decoder->id == CODEC_ID_MP2) ||
-     (codec->decoder->id == CODEC_ID_MP3))
+  if((codec->decoder->id == AV_CODEC_ID_MP2) ||
+     (codec->decoder->id == AV_CODEC_ID_MP3))
     read_packet_mpa(file, NULL, track);
-  else if(codec->decoder->id == CODEC_ID_AC3)
+  else if(codec->decoder->id == AV_CODEC_ID_AC3)
     read_packet_ac3(file, NULL, track);
   }
 
@@ -291,7 +291,7 @@ static int decode_audio_packet_ffmpeg(qu
     codec->avctx->bits_per_coded_sample = quicktime_audio_bits(file, track);
     /* Some codecs need extra stuff */
 
-    if(codec->decoder->id == CODEC_ID_ALAC)
+    if(codec->decoder->id == AV_CODEC_ID_ALAC)
       {
       header = quicktime_wave_get_user_atom(atrack->track, "alac", &header_len);
       if(header)
@@ -300,7 +300,7 @@ static int decode_audio_packet_ffmpeg(qu
         codec->avctx->extradata_size = header_len;
         }
       }
-    if(codec->decoder->id == CODEC_ID_QDM2)
+    if(codec->decoder->id == AV_CODEC_ID_QDM2)
       {
       header = quicktime_wave_get_user_atom(atrack->track, "QDCA", &header_len);
       if(header)
@@ -769,9 +769,9 @@ void quicktime_init_audio_codec_ffmpeg(q
 
   codec_base->set_parameter = set_parameter;
 
-  if((decoder->id == CODEC_ID_MP3) || (decoder->id == CODEC_ID_MP2))
+  if((decoder->id == AV_CODEC_ID_MP3) || (decoder->id == AV_CODEC_ID_MP2))
     codec_base->read_packet = read_packet_mpa;
-  else if(decoder->id == CODEC_ID_AC3)
+  else if(decoder->id == AV_CODEC_ID_AC3)
     {
     codec_base->write_packet = write_packet_ac3;
     codec_base->read_packet = read_packet_ac3;
Index: libquicktime/plugins/ffmpeg/lqt_ffmpeg.c
===================================================================
--- libquicktime.orig/plugins/ffmpeg/lqt_ffmpeg.c
+++ libquicktime/plugins/ffmpeg/lqt_ffmpeg.c
@@ -403,7 +403,7 @@ static lqt_image_size_static_t image_siz
 struct CODECIDMAP codecidmap_v[] =
   {
     {
-      .id = CODEC_ID_MPEG1VIDEO,
+      .id = AV_CODEC_ID_MPEG1VIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -414,7 +414,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE }
     },
     {
-      .id = CODEC_ID_MPEG4,
+      .id = AV_CODEC_ID_MPEG4,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -432,7 +432,7 @@ struct CODECIDMAP codecidmap_v[] =
       .compression_id = LQT_COMPRESSION_MPEG4_ASP,
     },
     {
-      .id = CODEC_ID_MSMPEG4V1,
+      .id = AV_CODEC_ID_MSMPEG4V1,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -443,7 +443,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_MSMPEG4V2,
+      .id = AV_CODEC_ID_MSMPEG4V2,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -454,7 +454,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_MSMPEG4V3,
+      .id = AV_CODEC_ID_MSMPEG4V3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -470,7 +470,7 @@ struct CODECIDMAP codecidmap_v[] =
       .do_encode = 1,
     },
     {
-      .id = CODEC_ID_MSMPEG4V3,
+      .id = AV_CODEC_ID_MSMPEG4V3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -485,7 +485,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #if 0
     {
-      .id = CODEC_ID_WMV1,
+      .id = AV_CODEC_ID_WMV1,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -498,7 +498,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #endif
     {
-      .id = CODEC_ID_H263,
+      .id = AV_CODEC_ID_H263,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -510,7 +510,7 @@ struct CODECIDMAP codecidmap_v[] =
       .compatibility_flags = LQT_FILE_QT_OLD | LQT_FILE_QT | LQT_FILE_MP4 | LQT_FILE_3GP,
     },
     {
-      .id = CODEC_ID_H263,
+      .id = AV_CODEC_ID_H263,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -525,7 +525,7 @@ struct CODECIDMAP codecidmap_v[] =
       .do_encode = 1,
     },
     {
-      .id = CODEC_ID_H264,
+      .id = AV_CODEC_ID_H264,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -536,7 +536,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_H263P,
+      .id = AV_CODEC_ID_H263P,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -550,7 +550,7 @@ struct CODECIDMAP codecidmap_v[] =
       .do_encode = 1,
     },
     {
-      .id = CODEC_ID_H263I,
+      .id = AV_CODEC_ID_H263I,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -561,7 +561,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_SVQ1,
+      .id = AV_CODEC_ID_SVQ1,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -572,7 +572,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_SVQ3,
+      .id = AV_CODEC_ID_SVQ3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -583,7 +583,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_MJPEG,
+      .id = AV_CODEC_ID_MJPEG,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -597,7 +597,7 @@ struct CODECIDMAP codecidmap_v[] =
       .do_encode = 1,
     },
     {
-      .id = CODEC_ID_MJPEGB,
+      .id = AV_CODEC_ID_MJPEGB,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -611,7 +611,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #if LIBAVCODEC_BUILD >= 3346688
     {
-      .id = CODEC_ID_TARGA,
+      .id = AV_CODEC_ID_TARGA,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -623,7 +623,7 @@ struct CODECIDMAP codecidmap_v[] =
 #endif
 #if LIBAVCODEC_BUILD >= 3347456
     {
-      .id = CODEC_ID_TIFF,
+      .id = AV_CODEC_ID_TIFF,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -634,7 +634,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #endif
     {
-      .id = CODEC_ID_8BPS,
+      .id = AV_CODEC_ID_8BPS,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -644,7 +644,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_INDEO3,
+      .id = AV_CODEC_ID_INDEO3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -655,7 +655,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_RPZA,
+      .id = AV_CODEC_ID_RPZA,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -665,7 +665,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_SMC,
+      .id = AV_CODEC_ID_SMC,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -675,7 +675,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_CINEPAK,
+      .id = AV_CODEC_ID_CINEPAK,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -686,7 +686,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_CYUV,
+      .id = AV_CODEC_ID_CYUV,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -697,7 +697,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_QTRLE,
+      .id = AV_CODEC_ID_QTRLE,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -711,7 +711,7 @@ struct CODECIDMAP codecidmap_v[] =
       .encoding_colormodels = (int[]){ BC_RGB888, BC_RGBA8888, LQT_COLORMODEL_NONE },
     },
     {
-      .id = CODEC_ID_MSRLE,
+      .id = AV_CODEC_ID_MSRLE,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -722,7 +722,7 @@ struct CODECIDMAP codecidmap_v[] =
       .wav_ids = { LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_DVVIDEO,
+      .id = AV_CODEC_ID_DVVIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -738,7 +738,7 @@ struct CODECIDMAP codecidmap_v[] =
       .image_sizes = image_sizes_dv,
     },
     {
-      .id = CODEC_ID_DVVIDEO,
+      .id = AV_CODEC_ID_DVVIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -754,7 +754,7 @@ struct CODECIDMAP codecidmap_v[] =
       .image_sizes = image_sizes_dv,
     },
     {
-      .id = CODEC_ID_DVVIDEO,
+      .id = AV_CODEC_ID_DVVIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -770,7 +770,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
     /* DVCPRO HD (decoding only for now) */
     {
-      .id = CODEC_ID_DVVIDEO,
+      .id = AV_CODEC_ID_DVVIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -791,7 +791,7 @@ struct CODECIDMAP codecidmap_v[] =
       // .do_encode = 1
     },
     {
-      .id = CODEC_ID_FFVHUFF,
+      .id = AV_CODEC_ID_FFVHUFF,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -804,7 +804,7 @@ struct CODECIDMAP codecidmap_v[] =
       .do_encode = 1
     },
     {
-      .id = CODEC_ID_FFV1,
+      .id = AV_CODEC_ID_FFV1,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -820,7 +820,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #if LIBAVCODEC_BUILD >= 3352576
     {
-      .id = CODEC_ID_DNXHD,
+      .id = AV_CODEC_ID_DNXHD,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -837,7 +837,7 @@ struct CODECIDMAP codecidmap_v[] =
     },
 #endif
     {
-      .id = CODEC_ID_MPEG2VIDEO,
+      .id = AV_CODEC_ID_MPEG2VIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -853,7 +853,7 @@ struct CODECIDMAP codecidmap_v[] =
       .compression_id = LQT_COMPRESSION_D10
     },
     {
-      .id = CODEC_ID_MPEG2VIDEO,
+      .id = AV_CODEC_ID_MPEG2VIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -867,7 +867,7 @@ struct CODECIDMAP codecidmap_v[] =
       .compatibility_flags = LQT_FILE_QT
     },
     {
-      .id = CODEC_ID_MPEG2VIDEO,
+      .id = AV_CODEC_ID_MPEG2VIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -879,7 +879,7 @@ struct CODECIDMAP codecidmap_v[] =
       .compatibility_flags = LQT_FILE_QT
     },
     {
-      .id = CODEC_ID_MPEG2VIDEO,
+      .id = AV_CODEC_ID_MPEG2VIDEO,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -896,7 +896,7 @@ struct CODECIDMAP codecidmap_v[] =
       .encoding_colormodels = (int[]){ BC_YUV422P, LQT_COLORMODEL_NONE }
     },
     {
-      .id = CODEC_ID_PRORES,
+      .id = AV_CODEC_ID_PRORES,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -917,7 +917,7 @@ struct CODECIDMAP codecidmap_v[] =
 struct CODECIDMAP codecidmap_a[] =
   {
     {
-      .id = CODEC_ID_MP3,
+      .id = AV_CODEC_ID_MP3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -929,7 +929,7 @@ struct CODECIDMAP codecidmap_a[] =
       .wav_ids = { 0x50, 0x55, LQT_WAV_ID_NONE },
     },
     {
-      .id = CODEC_ID_MP2,
+      .id = AV_CODEC_ID_MP2,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -944,7 +944,7 @@ struct CODECIDMAP codecidmap_a[] =
       .compression_id = LQT_COMPRESSION_MP2,
     },
     {
-      .id = CODEC_ID_AC3,
+      .id = AV_CODEC_ID_AC3,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -959,7 +959,7 @@ struct CODECIDMAP codecidmap_a[] =
       .compression_id = LQT_COMPRESSION_AC3,
     },
     {
-      .id = CODEC_ID_QDM2,
+      .id = AV_CODEC_ID_QDM2,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -974,7 +974,7 @@ struct CODECIDMAP codecidmap_a[] =
 #if 1
     /* Doesn't work as long as audio chunks are not split into VBR "Samples" */
     {
-      .id = CODEC_ID_ALAC,
+      .id = AV_CODEC_ID_ALAC,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -987,7 +987,7 @@ struct CODECIDMAP codecidmap_a[] =
 #if 1
     /* Sounds ugly */
     {
-      .id = CODEC_ID_ADPCM_MS,
+      .id = AV_CODEC_ID_ADPCM_MS,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -1000,7 +1000,7 @@ struct CODECIDMAP codecidmap_a[] =
 #if 1
     /* Sounds ugly */
     {
-      .id = CODEC_ID_ADPCM_IMA_WAV,
+      .id = AV_CODEC_ID_ADPCM_IMA_WAV,
       .index = -1,
       .encoder = NULL,
       .decoder = NULL,
@@ -1035,7 +1035,7 @@ static void ffmpeg_map_init(void)
     if(codecidmap_v[i].do_encode)
       {
       // FFMpeg has 2 different ProRes encoders, so try the better one first.
-      if(codecidmap_v[i].id == CODEC_ID_PRORES)
+      if(codecidmap_v[i].id == AV_CODEC_ID_PRORES)
         {
         // In newer versions it's called prores_ks. It used to be called prores_kostya
         codecidmap_v[i].encoder = avcodec_find_encoder_by_name("prores_ks");
Index: libquicktime/plugins/ffmpeg/video.c
===================================================================
--- libquicktime.orig/plugins/ffmpeg/video.c
+++ libquicktime/plugins/ffmpeg/video.c
@@ -37,9 +37,9 @@
 #endif
 
 #ifdef  PIX_FMT_YUV422P10
-#define PIX_FMT_YUV422P10_OR_DUMMY PIX_FMT_YUV422P10
+#define AV_PIX_FMT_YUV422P10_OR_DUMMY PIX_FMT_YUV422P10
 #else
-#define PIX_FMT_YUV422P10_OR_DUMMY -1234
+#define AV_PIX_FMT_YUV422P10_OR_DUMMY -1234
 #endif
 
 static const struct
@@ -102,7 +102,7 @@ typedef struct
 
   /* In some cases FFMpeg would report something like PIX_FMT_YUV422P, while
      we would like to treat it as PIX_FMT_YUVJ422P. It's only used for decoding */
-  enum PixelFormat reinterpret_pix_fmt;
+  enum AVPixelFormat reinterpret_pix_fmt;
   
   int is_imx;
   int is_xdcam_hd422;
@@ -146,42 +146,42 @@ typedef struct
 
 static const struct
   {
-  enum PixelFormat ffmpeg_id;
+  enum AVPixelFormat ffmpeg_id;
   int              lqt_id;
   int              exact;
   }
 colormodels[] =
   {
-    { PIX_FMT_YUV420P,   BC_YUV420P,   1 }, ///< Planar YUV 4:2:0 (1 Cr & Cb sample per 2x2 Y samples)
+    { AV_PIX_FMT_YUV420P,   BC_YUV420P,   1 }, ///< Planar YUV 4:2:0 (1 Cr & Cb sample per 2x2 Y samples)
 #if LIBAVUTIL_VERSION_INT < (50<<16)
-    { PIX_FMT_YUV422,    BC_YUV422,    1 },
+    { AV_PIX_FMT_YUV422,    BC_YUV422,    1 },
 #else
-    { PIX_FMT_YUYV422,   BC_YUV422,    1 },
+    { AV_PIX_FMT_YUYV422,   BC_YUV422,    1 },
 #endif
-    { PIX_FMT_RGB24,     BC_RGB888,    1 }, ///< Packed pixel, 3 bytes per pixel, RGBRGB...
-    { PIX_FMT_BGR24,     BC_BGR888,    1 }, ///< Packed pixel, 3 bytes per pixel, BGRBGR...
-    { PIX_FMT_YUV422P,   BC_YUV422P,   1 }, ///< Planar YUV 4:2:2 (1 Cr & Cb sample per 2x1 Y samples)
-    { PIX_FMT_YUV444P,   BC_YUV444P,   1 }, ///< Planar YUV 4:4:4 (1 Cr & Cb sample per 1x1 Y samples)
-    { PIX_FMT_YUV411P,   BC_YUV411P,   1 }, ///< Planar YUV 4:1:1 (1 Cr & Cb sample per 4x1 Y samples)
-    { PIX_FMT_YUV422P16, BC_YUV422P16, 1 }, ///< Planar 16 bit YUV 4:2:2 (1 Cr & Cb sample per 2x1 Y samples)
-#ifdef PIX_FMT_YUV422P10
-    { PIX_FMT_YUV422P10, BC_YUV422P10, 1 }, ///< 10 bit samples in uint16_t containers, planar 4:2:2
+    { AV_PIX_FMT_RGB24,     BC_RGB888,    1 }, ///< Packed pixel, 3 bytes per pixel, RGBRGB...
+    { AV_PIX_FMT_BGR24,     BC_BGR888,    1 }, ///< Packed pixel, 3 bytes per pixel, BGRBGR...
+    { AV_PIX_FMT_YUV422P,   BC_YUV422P,   1 }, ///< Planar YUV 4:2:2 (1 Cr & Cb sample per 2x1 Y samples)
+    { AV_PIX_FMT_YUV444P,   BC_YUV444P,   1 }, ///< Planar YUV 4:4:4 (1 Cr & Cb sample per 1x1 Y samples)
+    { AV_PIX_FMT_YUV411P,   BC_YUV411P,   1 }, ///< Planar YUV 4:1:1 (1 Cr & Cb sample per 4x1 Y samples)
+    { AV_PIX_FMT_YUV422P16, BC_YUV422P16, 1 }, ///< Planar 16 bit YUV 4:2:2 (1 Cr & Cb sample per 2x1 Y samples)
+#ifdef AV_PIX_FMT_YUV422P10
+    { AV_PIX_FMT_YUV422P10, BC_YUV422P10, 1 }, ///< 10 bit samples in uint16_t containers, planar 4:2:2
 #endif
-    { PIX_FMT_RGB565,    BC_RGB565,    1 }, ///< always stored in cpu endianness
-    { PIX_FMT_YUVJ420P,  BC_YUVJ420P,  1 }, ///< Planar YUV 4:2:0 full scale (jpeg)
-    { PIX_FMT_YUVJ422P,  BC_YUVJ422P,  1 }, ///< Planar YUV 4:2:2 full scale (jpeg)
-    { PIX_FMT_YUVJ444P,  BC_YUVJ444P,  1 }, ///< Planar YUV 4:4:4 full scale (jpeg)
+    { AV_PIX_FMT_RGB565,    BC_RGB565,    1 }, ///< always stored in cpu endianness
+    { AV_PIX_FMT_YUVJ420P,  BC_YUVJ420P,  1 }, ///< Planar YUV 4:2:0 full scale (jpeg)
+    { AV_PIX_FMT_YUVJ422P,  BC_YUVJ422P,  1 }, ///< Planar YUV 4:2:2 full scale (jpeg)
+    { AV_PIX_FMT_YUVJ444P,  BC_YUVJ444P,  1 }, ///< Planar YUV 4:4:4 full scale (jpeg)
 #if LIBAVUTIL_VERSION_INT < (50<<16)
-    { PIX_FMT_RGBA32,    BC_RGBA8888,  0 }, ///< Packed pixel, 4 bytes per pixel, BGRABGRA...
+    { AV_PIX_FMT_RGBA32,    BC_RGBA8888,  0 }, ///< Packed pixel, 4 bytes per pixel, BGRABGRA...
 #else
-    { PIX_FMT_RGB32,     BC_RGBA8888,  0 }, ///< Packed pixel, 4 bytes per pixel, BGRABGRA...
+    { AV_PIX_FMT_RGB32,     BC_RGBA8888,  0 }, ///< Packed pixel, 4 bytes per pixel, BGRABGRA...
 #endif
-    { PIX_FMT_RGB555,    BC_RGB888,    0 }, ///< always stored in cpu endianness, most significant bit to 1
-    { PIX_FMT_GRAY8,     BC_RGB888,    0 },
-    { PIX_FMT_MONOWHITE, BC_RGB888,    0 }, ///< 0 is white
-    { PIX_FMT_MONOBLACK, BC_RGB888,    0 }, ///< 0 is black
-    { PIX_FMT_PAL8,      BC_RGB888,    0 }, ///< 8 bit with RGBA palette
-    { PIX_FMT_YUV410P,   BC_YUV420P,   0 }, ///< Planar YUV 4:1:0 (1 Cr & Cb sample per 4x4 Y samples)
+    { AV_PIX_FMT_RGB555,    BC_RGB888,    0 }, ///< always stored in cpu endianness, most significant bit to 1
+    { AV_PIX_FMT_GRAY8,     BC_RGB888,    0 },
+    { AV_PIX_FMT_MONOWHITE, BC_RGB888,    0 }, ///< 0 is white
+    { AV_PIX_FMT_MONOBLACK, BC_RGB888,    0 }, ///< 0 is black
+    { AV_PIX_FMT_PAL8,      BC_RGB888,    0 }, ///< 8 bit with RGBA palette
+    { AV_PIX_FMT_YUV410P,   BC_YUV420P,   0 }, ///< Planar YUV 4:1:0 (1 Cr & Cb sample per 4x4 Y samples)
   };
 
 static const struct
@@ -333,7 +333,7 @@ static void maybe_add_sdtp_entry(quickti
   quicktime_video_map_t *vtrack = &file->vtracks[track];
   quicktime_ffmpeg_video_codec_t *codec = vtrack->codec->priv;
 
-  if (codec->encoder->id == CODEC_ID_MPEG2VIDEO && codec->avctx->gop_size > 1)
+  if (codec->encoder->id == AV_CODEC_ID_MPEG2VIDEO && codec->avctx->gop_size > 1)
     {
     uint8_t flags = generate_sdtp_flags_mpeg2(sample, codec->avctx);
     quicktime_insert_sdtp_entry(file, sample, track, flags);
@@ -392,16 +392,16 @@ static int lqt_tenbit_dnxhd_supported(AV
   if (!codec->pix_fmts)
     return 0;
 
-  for (i = 0; codec->pix_fmts[i] != PIX_FMT_NONE; ++i)
+  for (i = 0; codec->pix_fmts[i] != AV_PIX_FMT_NONE; ++i)
     {
-    if (codec->pix_fmts[i] == PIX_FMT_YUV422P10_OR_DUMMY)
+    if (codec->pix_fmts[i] == AV_PIX_FMT_YUV422P10_OR_DUMMY)
       return 1;
     }
 
   return 0;
   }
 
-static enum PixelFormat lqt_ffmpeg_get_ffmpeg_colormodel(int id)
+static enum AVPixelFormat lqt_ffmpeg_get_ffmpeg_colormodel(int id)
   {
   int i;
 
@@ -410,10 +410,10 @@ static enum PixelFormat lqt_ffmpeg_get_f
     if(colormodels[i].lqt_id == id)
       return colormodels[i].ffmpeg_id;
     }
-  return PIX_FMT_NB;
+  return AV_PIX_FMT_NB;
   }
 
-static int lqt_ffmpeg_get_lqt_colormodel(enum PixelFormat id, int * exact)
+static int lqt_ffmpeg_get_lqt_colormodel(enum AVPixelFormat id, int * exact)
   {
   int i;
 
@@ -454,23 +454,23 @@ static void lqt_ffmpeg_setup_decoding_co
      if (lqt_ffmpeg_get_avid_yuv_range(vtrack->track) == AVID_FULL_YUV_RANGE)
        {
        vtrack->stream_cmodel = BC_YUVJ422P;
-       codec->reinterpret_pix_fmt = PIX_FMT_YUVJ422P;
+       codec->reinterpret_pix_fmt = AV_PIX_FMT_YUVJ422P;
        *exact = 1;
        return;
        }
     }
-  else if(codec->decoder->id == CODEC_ID_DNXHD)
+  else if(codec->decoder->id == AV_CODEC_ID_DNXHD)
     {
     /* FFMpeg supports PIX_FMT_YUV422P and PIX_FMT_YUV422P10 for DNxHD, which
        we sometimes interpret as PIX_FMT_YUVJ422P and PIX_FMT_YUVJ422P10. */
-    if (codec->avctx->pix_fmt == PIX_FMT_YUV422P || codec->avctx->pix_fmt == PIX_FMT_YUV422P10_OR_DUMMY)
+    if (codec->avctx->pix_fmt == AV_PIX_FMT_YUV422P || codec->avctx->pix_fmt == AV_PIX_FMT_YUV422P10_OR_DUMMY)
       {
-      int p10 = (codec->avctx->pix_fmt == PIX_FMT_YUV422P10_OR_DUMMY);
+      int p10 = (codec->avctx->pix_fmt == AV_PIX_FMT_YUV422P10_OR_DUMMY);
       *exact = 1;
       if (lqt_ffmpeg_get_avid_yuv_range(vtrack->track) == AVID_FULL_YUV_RANGE)
         {
         vtrack->stream_cmodel = p10 ? BC_YUVJ422P10 : BC_YUVJ422P;
-        codec->reinterpret_pix_fmt = p10 ? PIX_FMT_YUV422P10_OR_DUMMY : PIX_FMT_YUVJ422P;
+        codec->reinterpret_pix_fmt = p10 ? AV_PIX_FMT_YUV422P10_OR_DUMMY : AV_PIX_FMT_YUVJ422P;
         // Note: reinterpret_pix_fmt should really be PIX_FMT_YUVJ422P10, except
         // there is no such colormodel in FFMpeg. Fortunately, it's not a problem
         // in this case, as reinterpret_pix_fmt is only used when *exact == 0.
@@ -478,7 +478,7 @@ static void lqt_ffmpeg_setup_decoding_co
       else
         {
         vtrack->stream_cmodel = p10 ? BC_YUV422P10 : BC_YUV422P;
-        codec->reinterpret_pix_fmt = p10 ? PIX_FMT_YUV422P10_OR_DUMMY : PIX_FMT_YUV422P;
+        codec->reinterpret_pix_fmt = p10 ? AV_PIX_FMT_YUV422P10_OR_DUMMY : AV_PIX_FMT_YUV422P;
         }
       return;
       }
@@ -497,16 +497,16 @@ static void lqt_ffmpeg_setup_encoding_co
   quicktime_ffmpeg_video_codec_t *codec = vtrack->codec->priv;
   codec->avctx->pix_fmt = lqt_ffmpeg_get_ffmpeg_colormodel(vtrack->stream_cmodel);
 
-  if (codec->encoder->id == CODEC_ID_DNXHD)
+  if (codec->encoder->id == AV_CODEC_ID_DNXHD)
     {
     /* FFMpeg's DNxHD encoder only supports PIX_FMT_YUV422P and PIX_FMT_YUV422P10
        and doesn't know anything about PIX_FMT_YUVJ422P and PIX_FMT_YUVJ422P10
        (in fact, the latter doesn't even exist) */
-    codec->avctx->pix_fmt = PIX_FMT_YUV422P;
+    codec->avctx->pix_fmt = AV_PIX_FMT_YUV422P;
     if (vtrack->stream_cmodel == BC_YUV422P10 || vtrack->stream_cmodel == BC_YUVJ422P10)
       {
       if (lqt_tenbit_dnxhd_supported(codec->encoder))
-        codec->avctx->pix_fmt = PIX_FMT_YUV422P10_OR_DUMMY;
+        codec->avctx->pix_fmt = AV_PIX_FMT_YUV422P10_OR_DUMMY;
       }
     }
   }
@@ -589,7 +589,7 @@ static void convert_rgba_to_argb(uint8_t
  */
 
 static void convert_image_decode(quicktime_ffmpeg_video_codec_t *codec,
-                                 AVFrame * in_frame, enum PixelFormat in_format,
+                                 AVFrame * in_frame, enum AVPixelFormat in_format,
                                  unsigned char ** out_frame, int out_format,
                                  int width, int height, int row_span, int row_span_uv)
   {
@@ -606,9 +606,9 @@ static void convert_image_decode(quickti
    *  RGBA format like in ffmpeg??
    */
 #if LIBAVUTIL_VERSION_INT < (50<<16)
-  if((in_format == PIX_FMT_RGBA32) && (out_format == BC_RGBA8888))
+  if((in_format == AV_PIX_FMT_RGBA32) && (out_format == BC_RGBA8888))
 #else
-    if((in_format == PIX_FMT_RGB32) && (out_format == BC_RGBA8888))
+    if((in_format == AV_PIX_FMT_RGB32) && (out_format == BC_RGBA8888))
 #endif
       {
       convert_image_decode_rgba(in_frame, out_frame, width, height, codec->y_offset);
@@ -782,13 +782,13 @@ static int lqt_ffmpeg_decode_video(quick
     codec->avctx->bits_per_coded_sample = quicktime_video_depth(file, track);
     /* Set extradata: It's done differently for each codec */
 
-    if(codec->decoder->id == CODEC_ID_SVQ3)
+    if(codec->decoder->id == AV_CODEC_ID_SVQ3)
       {
       extradata       = trak->mdia.minf.stbl.stsd.table[0].table_raw + 4;
       extradata_size  = trak->mdia.minf.stbl.stsd.table[0].table_raw_size - 4;
       
       }
-    else if(codec->decoder->id == CODEC_ID_H264)
+    else if(codec->decoder->id == AV_CODEC_ID_H264)
       {
       user_atom = quicktime_stsd_get_user_atom(trak, "avcC", &user_atom_len);
 
@@ -807,7 +807,7 @@ static int lqt_ffmpeg_decode_video(quick
         }
       
       }
-    else if(codec->decoder->id == CODEC_ID_MPEG4)
+    else if(codec->decoder->id == AV_CODEC_ID_MPEG4)
       {
       if(trak->mdia.minf.stbl.stsd.table[0].has_esds)
         {
@@ -936,10 +936,10 @@ static int lqt_ffmpeg_decode_video(quick
 #ifdef HAVE_LIBSWSCALE
 
 #if LIBAVUTIL_VERSION_INT < (50<<16)
-      if(!((codec->avctx->pix_fmt == PIX_FMT_RGBA32) &&
+      if(!((codec->avctx->pix_fmt == AV_PIX_FMT_RGBA32) &&
            (vtrack->stream_cmodel == BC_RGBA8888)))
 #else
-        if(!((codec->avctx->pix_fmt == PIX_FMT_RGB32) &&
+        if(!((codec->avctx->pix_fmt == AV_PIX_FMT_RGB32) &&
              (vtrack->stream_cmodel == BC_RGBA8888)))
 #endif
           {
@@ -954,15 +954,15 @@ static int lqt_ffmpeg_decode_video(quick
           }
 #endif
       }
-    if(codec->decoder->id == CODEC_ID_DVVIDEO)
+    if(codec->decoder->id == AV_CODEC_ID_DVVIDEO)
       {
       if(vtrack->stream_cmodel == BC_YUV420P)
         vtrack->chroma_placement = LQT_CHROMA_PLACEMENT_DVPAL;
       vtrack->interlace_mode = LQT_INTERLACE_BOTTOM_FIRST;
       vtrack->ci.id = LQT_COMPRESSION_DV;
       }
-    else if((codec->decoder->id == CODEC_ID_MPEG4) ||
-            (codec->decoder->id == CODEC_ID_H264))
+    else if((codec->decoder->id == AV_CODEC_ID_MPEG4) ||
+            (codec->decoder->id == AV_CODEC_ID_H264))
       {
       if(vtrack->stream_cmodel == BC_YUV420P)
         vtrack->chroma_placement = LQT_CHROMA_PLACEMENT_MPEG2;
@@ -1409,7 +1409,7 @@ static int init_xdcam_hd422_encoder(quic
   int frame_duration = lqt_frame_duration(file, track, NULL);
   const char* fourcc;
 
-  codec->avctx->pix_fmt = PIX_FMT_YUV422P;
+  codec->avctx->pix_fmt = AV_PIX_FMT_YUV422P;
   codec->avctx->gop_size = time_scale > 25 * frame_duration ? 15 : 12;
   codec->avctx->max_b_frames = 2;
   codec->avctx->intra_dc_precision = 2;
@@ -1606,13 +1606,13 @@ static int lqt_ffmpeg_encode_video(quick
     {
     if(vtrack->stream_cmodel == BC_YUV420P)
       {
-      if(codec->encoder->id == CODEC_ID_MPEG4)
+      if(codec->encoder->id == AV_CODEC_ID_MPEG4)
         {
         vtrack->chroma_placement = LQT_CHROMA_PLACEMENT_MPEG2;
         /* enable interlaced encoding */
         vtrack->interlace_mode = LQT_INTERLACE_NONE;
         }
-      else if(codec->encoder->id == CODEC_ID_DVVIDEO)
+      else if(codec->encoder->id == AV_CODEC_ID_DVVIDEO)
         {
         vtrack->chroma_placement = LQT_CHROMA_PLACEMENT_DVPAL;
         }
@@ -1637,9 +1637,9 @@ static int lqt_ffmpeg_encode_video(quick
     switch(codec->encoder->id)
       {
       // Variable duration frames won't work for these.
-      case CODEC_ID_MPEG2VIDEO:
-      case CODEC_ID_DVVIDEO:
-      case CODEC_ID_DNXHD:
+      case AV_CODEC_ID_MPEG2VIDEO:
+      case AV_CODEC_ID_DVVIDEO:
+      case AV_CODEC_ID_DNXHD:
           codec->encoding_pts_factor = lqt_frame_duration(file, track, NULL);
           codec->avctx->time_base.num = codec->encoding_pts_factor;
           // time_base may be reduced by a common factor by libavcodec,
@@ -1663,7 +1663,7 @@ static int lqt_ffmpeg_encode_video(quick
     codec->avctx->sample_aspect_ratio.num = pixel_width;
     codec->avctx->sample_aspect_ratio.den = pixel_height;
     /* Use global headers for mp4v */
-    if(codec->encoder->id == CODEC_ID_MPEG4)
+    if(codec->encoder->id == AV_CODEC_ID_MPEG4)
       {
       if(!(file->file_type & (LQT_FILE_AVI|LQT_FILE_AVI_ODML)))
         {
@@ -1687,12 +1687,12 @@ static int lqt_ffmpeg_encode_video(quick
         }
 #endif
       }
-    else if((codec->encoder->id == CODEC_ID_MSMPEG4V3) && (trak->strl) &&
+    else if((codec->encoder->id == AV_CODEC_ID_MSMPEG4V3) && (trak->strl) &&
             !strncmp(trak->strl->strf.bh.biCompression, "DIV3", 4))
       {
       strncpy(trak->strl->strh.fccHandler, "div3", 4);
       }
-    else if((codec->encoder->id == CODEC_ID_H263) &&
+    else if((codec->encoder->id == AV_CODEC_ID_H263) &&
             (file->file_type & (LQT_FILE_MP4|LQT_FILE_3GP)))
       {
       uint8_t d263_data[] =
@@ -1706,7 +1706,7 @@ static int lqt_ffmpeg_encode_video(quick
       strncpy(trak->mdia.minf.stbl.stsd.table[0].format,
               "s263", 4);
       }
-    else if(codec->encoder->id == CODEC_ID_FFVHUFF)
+    else if(codec->encoder->id == AV_CODEC_ID_FFVHUFF)
       {
       if(!(file->file_type & (LQT_FILE_AVI|LQT_FILE_AVI_ODML)))
         {
@@ -1714,22 +1714,22 @@ static int lqt_ffmpeg_encode_video(quick
         codec->write_global_header = 1;
         }
       }
-    else if(codec->encoder->id == CODEC_ID_QTRLE)
+    else if(codec->encoder->id == AV_CODEC_ID_QTRLE)
       {
       if(vtrack->stream_cmodel == BC_RGBA8888)
         {
         /* Libquicktime doesn't natively support a color model equivalent
            to PIX_FMT_ARGB, which is required for QTRLE with alpha channel.
            So, we use BC_RGBA8888 and do ad hoc conversion below. */
-        codec->avctx->pix_fmt = PIX_FMT_ARGB;
+        codec->avctx->pix_fmt = AV_PIX_FMT_ARGB;
         vtrack->track->mdia.minf.stbl.stsd.table[0].depth = 32;
         }
       }
-    else if(codec->encoder->id == CODEC_ID_DVVIDEO)
+    else if(codec->encoder->id == AV_CODEC_ID_DVVIDEO)
       {
       set_dv_fourcc(width, height, vtrack->stream_cmodel, trak);
       }
-    else if(codec->encoder->id == CODEC_ID_DNXHD)
+    else if(codec->encoder->id == AV_CODEC_ID_DNXHD)
       {
       if(vtrack->interlace_mode != LQT_INTERLACE_NONE)
         {
@@ -1740,7 +1740,7 @@ static int lqt_ffmpeg_encode_video(quick
       init_imx_encoder(file, track);
     else if(codec->is_xdcam_hd422)
       init_xdcam_hd422_encoder(file, track);
-    else if(codec->encoder->id == CODEC_ID_PRORES)
+    else if(codec->encoder->id == AV_CODEC_ID_PRORES)
       init_prores_encoder(file, track);
     
     /* Initialize 2-pass */
@@ -1782,7 +1782,7 @@ static int lqt_ffmpeg_encode_video(quick
     }
   //        codec->lqt_colormodel = ffmepg_2_lqt(codec->com.ffcodec_enc);
 
-  if(codec->y_offset != 0 || codec->avctx->pix_fmt == PIX_FMT_ARGB)
+  if(codec->y_offset != 0 || codec->avctx->pix_fmt == AV_PIX_FMT_ARGB)
     {
     if(!codec->tmp_rows)
       {
@@ -1807,7 +1807,7 @@ static int lqt_ffmpeg_encode_video(quick
                         vtrack->stream_cmodel,
                         0, 0, 0, codec->y_offset);
       }
-    else if(codec->avctx->pix_fmt == PIX_FMT_ARGB)
+    else if(codec->avctx->pix_fmt == AV_PIX_FMT_ARGB)
       {
       convert_rgba_to_argb(row_pointers[0], vtrack->stream_row_span,
                            codec->tmp_rows[0], codec->tmp_row_span,
@@ -1861,12 +1861,12 @@ static int lqt_ffmpeg_encode_video(quick
   if(kf && codec->is_xdcam_hd422 && vtrack->cur_chunk)
     kf = LQT_PARTIAL_KEY_FRAME; // For XDCAM, only the first key frame is full key frame.
 
-  if(!was_initialized && codec->encoder->id == CODEC_ID_DNXHD)
+  if(!was_initialized && codec->encoder->id == AV_CODEC_ID_DNXHD)
     setup_avid_atoms(file, vtrack, codec->lqt_pkt.data, bytes_encoded);
   
   if(bytes_encoded)
     {
-    if (pts == AV_NOPTS_VALUE || (codec->encoder->id == CODEC_ID_DNXHD && pts == 0))
+    if (pts == AV_NOPTS_VALUE || (codec->encoder->id == AV_CODEC_ID_DNXHD && pts == 0))
       {
       /* Some codecs don't bother generating presentation timestamps.
          FFMpeg's DNxHD encoder doesn't even bother to set it to AV_NOPTS_VALUE. */
@@ -1899,13 +1899,13 @@ static int lqt_ffmpeg_encode_video(quick
 
   if(codec->write_global_header && !codec->global_header_written)
     {
-    if(codec->encoder->id == CODEC_ID_FFVHUFF)
+    if(codec->encoder->id == AV_CODEC_ID_FFVHUFF)
       {
       quicktime_user_atoms_add_atom(&trak->mdia.minf.stbl.stsd.table[0].user_atoms,
                                     "glbl",
                                     codec->avctx->extradata, codec->avctx->extradata_size );
       }
-    else if(codec->encoder->id == CODEC_ID_MPEG4)
+    else if(codec->encoder->id == AV_CODEC_ID_MPEG4)
       {
       int advanced = 0;
       if(codec->avctx->max_b_frames ||
@@ -2235,13 +2235,13 @@ void quicktime_init_video_codec_ffmpeg(q
     codec_base->encode_video = lqt_ffmpeg_encode_video;
     codec_base->set_pass = set_pass_ffmpeg;
 
-    if(encoder->id == CODEC_ID_MPEG4)
+    if(encoder->id == AV_CODEC_ID_MPEG4)
       {
       codec_base->writes_compressed = writes_compressed_mpeg4;
       codec_base->init_compressed   = init_compressed_mpeg4;
       codec_base->write_packet = write_packet_mpeg4;
       }
-    else if(encoder->id == CODEC_ID_DVVIDEO)
+    else if(encoder->id == AV_CODEC_ID_DVVIDEO)
       {
       codec_base->init_compressed = init_compressed_dv;
       }
@@ -2249,7 +2249,7 @@ void quicktime_init_video_codec_ffmpeg(q
     }
   if(decoder)
     {
-    if(decoder->id == CODEC_ID_H264)
+    if(decoder->id == AV_CODEC_ID_H264)
       codec_base->read_packet = read_packet_h264;
     codec_base->decode_video = lqt_ffmpeg_decode_video;
     }
